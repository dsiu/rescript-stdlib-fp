// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as $$Array from "rescript/lib/es6/array.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as TableclothMap from "./TableclothMap.mjs";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";

function singleton(x) {
  return {
          hd: x,
          tl: /* [] */0
        };
}

function fromArray(array) {
  return List.init(array.length, (function (i) {
                return Caml_array.get(array, i);
              }));
}

function range(fromOpt, to_) {
  var from = fromOpt !== undefined ? fromOpt : 0;
  if (to_ < from) {
    return /* [] */0;
  } else {
    return List.init(to_ - from | 0, (function (i) {
                  return i + from | 0;
                }));
  }
}

function repeat(element, times) {
  if (times <= 0) {
    return /* [] */0;
  } else {
    return {
            hd: element,
            tl: repeat(element, times - 1 | 0)
          };
  }
}

var flatten = Belt_List.flatten;

var reverse = Belt_List.reverse;

var append = Belt_List.concat;

function sum(t, M) {
  return List.fold_left(M.add, M.zero, t);
}

function map(t, f) {
  return Belt_List.map(t, Curry.__1(f));
}

function flatMap(t, f) {
  return Belt_List.flatten(Belt_List.map(t, Curry.__1(f)));
}

function mapWithIndex(list, f) {
  return Belt_List.mapWithIndex(list, Curry.__2(f));
}

function map2(a, b, f) {
  return Belt_List.zipBy(a, b, Curry.__2(f));
}

function zip(a, b) {
  return map2(a, b, (function (a, b) {
                return [
                        a,
                        b
                      ];
              }));
}

function map3(a, b, c, f) {
  if (a && b && c) {
    return {
            hd: Curry._3(f, a.hd, b.hd, c.hd),
            tl: map3(a.tl, b.tl, c.tl, f)
          };
  } else {
    return /* [] */0;
  }
}

function last(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    var rest = l.tl;
    if (!rest) {
      return Caml_option.some(l.hd);
    }
    _l = rest;
    continue ;
  };
}

function unzip(list) {
  return [
          List.map((function (param) {
                  return param[0];
                }), list),
          List.map((function (param) {
                  return param[1];
                }), list)
        ];
}

function includes(t, value, equal) {
  return Belt_List.has(t, value, Curry.__2(equal));
}

function uniqueBy(l, f) {
  var _existing;
  var _remaining = l;
  var _accumulator = /* [] */0;
  while(true) {
    var accumulator = _accumulator;
    var remaining = _remaining;
    var existing = _existing;
    if (!remaining) {
      return Belt_List.reverse(accumulator);
    }
    var rest = remaining.tl;
    var first = remaining.hd;
    var computedFirst = Curry._1(f, first);
    if (Belt_SetString.has(existing, computedFirst)) {
      _remaining = rest;
      continue ;
    }
    _accumulator = {
      hd: first,
      tl: accumulator
    };
    _remaining = rest;
    _existing = Belt_SetString.add(existing, computedFirst);
    continue ;
  };
}

function find(t, f) {
  return Belt_List.getBy(t, Curry.__1(f));
}

var getAt = Belt_List.get;

function any(t, f) {
  return List.exists(Curry.__1(f), t);
}

var head = Belt_List.head;

function drop(t, count) {
  var v = Belt_List.drop(t, count);
  if (v !== undefined) {
    return v;
  } else if (count <= 0) {
    return t;
  } else {
    return /* [] */0;
  }
}

function take(t, count) {
  var v = Belt_List.take(t, count);
  if (v !== undefined) {
    return v;
  } else if (count <= 0) {
    return /* [] */0;
  } else {
    return t;
  }
}

function initial(l) {
  var match = Belt_List.reverse(l);
  if (match) {
    return Belt_List.reverse(match.tl);
  }
  
}

function filterMap(t, f) {
  return Belt_List.keepMap(t, Curry.__1(f));
}

function filter(t, f) {
  return Belt_List.keep(t, Curry.__1(f));
}

function filterWithIndex(t, f) {
  return Belt_List.keepWithIndex(t, (function (e, i) {
                return Curry._2(f, i, e);
              }));
}

function partition(t, f) {
  return Belt_List.partition(t, Curry.__1(f));
}

function fold(t, initial, f) {
  return Belt_List.reduce(t, initial, Curry.__2(f));
}

function count(t, f) {
  return fold(t, 0, (function (total, element) {
                return total + (
                        Curry._1(f, element) ? 1 : 0
                      ) | 0;
              }));
}

function foldRight(t, initial, f) {
  return Belt_List.reduceReverse(t, initial, Curry.__2(f));
}

function findIndex(list, f) {
  var _i = 0;
  var _l = list;
  while(true) {
    var l = _l;
    var i = _i;
    if (!l) {
      return ;
    }
    var x = l.hd;
    if (Curry._2(f, i, x)) {
      return [
              i,
              x
            ];
    }
    _l = l.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function splitAt(t, index) {
  return [
          take(t, index),
          drop(t, index)
        ];
}

function updateAt(t, index, f) {
  return Belt_List.mapWithIndex(t, (function (i, element) {
                if (i === index) {
                  return Curry._1(f, element);
                } else {
                  return element;
                }
              }));
}

var length = Belt_List.length;

function dropWhile(_t, f) {
  while(true) {
    var t = _t;
    if (!t) {
      return /* [] */0;
    }
    if (!Curry._1(f, t.hd)) {
      return t;
    }
    _t = t.tl;
    continue ;
  };
}

function isEmpty(t) {
  return t === /* [] */0;
}

function sliding(stepOpt, t, size) {
  var step = stepOpt !== undefined ? stepOpt : 1;
  var loop = function (t) {
    if (t === /* [] */0) {
      return /* [] */0;
    }
    var sample = Belt_List.take(t, size);
    var rest = Belt_List.drop(t, step);
    if (sample !== undefined) {
      if (rest !== undefined) {
        return {
                hd: sample,
                tl: loop(rest)
              };
      } else {
        return {
                hd: sample,
                tl: /* [] */0
              };
      }
    } else {
      return /* [] */0;
    }
  };
  return loop(t);
}

function chunksOf(t, size) {
  return sliding(size, t, size);
}

function cons(t, element) {
  return {
          hd: element,
          tl: t
        };
}

function takeWhile(t, f) {
  var _acc = /* [] */0;
  var _t = t;
  while(true) {
    var t$1 = _t;
    var acc = _acc;
    if (!t$1) {
      return Belt_List.reverse(acc);
    }
    var x = t$1.hd;
    if (!Curry._1(f, x)) {
      return Belt_List.reverse(acc);
    }
    _t = t$1.tl;
    _acc = {
      hd: x,
      tl: acc
    };
    continue ;
  };
}

function all(t, f) {
  return Belt_List.every(t, Curry.__1(f));
}

function tail(t) {
  if (t) {
    return t.tl;
  }
  
}

function removeAt(t, index) {
  if (index < 0) {
    return t;
  }
  var match = splitAt(t, index);
  var t$1 = tail(match[1]);
  if (t$1 !== undefined) {
    return Belt_List.concat(match[0], t$1);
  } else {
    return t;
  }
}

function minimumBy(f, l) {
  var minBy = function (param, x) {
    var fy = param[1];
    var fx = Curry._1(f, x);
    if (Caml_obj.lessthan(fx, fy)) {
      return [
              x,
              fx
            ];
    } else {
      return [
              param[0],
              fy
            ];
    }
  };
  if (!l) {
    return ;
  }
  var rest = l.tl;
  var x = l.hd;
  if (rest) {
    return Caml_option.some(fold(rest, [
                      x,
                      Curry._1(f, x)
                    ], minBy)[0]);
  } else {
    return Caml_option.some(x);
  }
}

function maximumBy(f, l) {
  var maxBy = function (param, x) {
    var fy = param[1];
    var fx = Curry._1(f, x);
    if (Caml_obj.greaterthan(fx, fy)) {
      return [
              x,
              fx
            ];
    } else {
      return [
              param[0],
              fy
            ];
    }
  };
  if (!l) {
    return ;
  }
  var rest = l.tl;
  var x = l.hd;
  if (rest) {
    return Caml_option.some(fold(rest, [
                      x,
                      Curry._1(f, x)
                    ], maxBy)[0]);
  } else {
    return Caml_option.some(x);
  }
}

function minimum(t, compare) {
  return fold(t, undefined, (function (min, element) {
                if (min !== undefined && Curry._2(compare, element, Caml_option.valFromOption(min)) >= 0) {
                  return min;
                } else {
                  return Caml_option.some(element);
                }
              }));
}

function maximum(t, compare) {
  return fold(t, undefined, (function (max, element) {
                if (max !== undefined && Curry._2(compare, element, Caml_option.valFromOption(max)) <= 0) {
                  return max;
                } else {
                  return Caml_option.some(element);
                }
              }));
}

function extent(t, compare) {
  return fold(t, undefined, (function (current, element) {
                if (current === undefined) {
                  return [
                          element,
                          element
                        ];
                }
                var max = current[1];
                var min = current[0];
                return [
                        Curry._2(compare, element, min) < 0 ? element : min,
                        Curry._2(compare, element, max) > 0 ? element : max
                      ];
              }));
}

function sort(t, compare) {
  return Belt_List.sort(t, Curry.__2(compare));
}

function sortBy(l, f) {
  return Belt_List.sort(l, (function (a, b) {
                var a$p = Curry._1(f, a);
                var b$p = Curry._1(f, b);
                if (Caml_obj.equal(a$p, b$p)) {
                  return 0;
                } else if (Caml_obj.lessthan(a$p, b$p)) {
                  return -1;
                } else {
                  return 1;
                }
              }));
}

function groupWhile(l, f) {
  var $$break = function (param, x, y) {
    return Curry._2(f, x, y);
  };
  var groups = Belt_List.reduceWithIndex(l, /* [] */0, (function (acc, x, i) {
          if (!acc) {
            return {
                    hd: {
                      hd: x,
                      tl: /* [] */0
                    },
                    tl: /* [] */0
                  };
          }
          var tl = acc.tl;
          var current_group = acc.hd;
          if (Curry._3($$break, i, Belt_List.headExn(current_group), x)) {
            return {
                    hd: {
                      hd: x,
                      tl: /* [] */0
                    },
                    tl: {
                      hd: current_group,
                      tl: tl
                    }
                  };
          } else {
            return {
                    hd: {
                      hd: x,
                      tl: current_group
                    },
                    tl: tl
                  };
          }
        }));
  if (groups) {
    return Belt_List.mapReverse(groups, reverse);
  } else {
    return /* [] */0;
  }
}

function insertAt(t, index, value) {
  var match = splitAt(t, index);
  return Belt_List.concat(match[0], {
              hd: value,
              tl: match[1]
            });
}

function splitWhen(t, f) {
  var _front = /* [] */0;
  var _back = t;
  while(true) {
    var back = _back;
    var front = _front;
    if (!back) {
      return [
              t,
              /* [] */0
            ];
    }
    var element = back.hd;
    if (Curry._1(f, element)) {
      return [
              Belt_List.reverse(front),
              back
            ];
    }
    _back = back.tl;
    _front = {
      hd: element,
      tl: front
    };
    continue ;
  };
}

function intersperse(t, sep) {
  if (!t) {
    return /* [] */0;
  }
  var rest = t.tl;
  var x = t.hd;
  if (rest) {
    return {
            hd: x,
            tl: foldRight(rest, /* [] */0, (function (acc, x) {
                    return {
                            hd: sep,
                            tl: {
                              hd: x,
                              tl: acc
                            }
                          };
                  }))
          };
  } else {
    return {
            hd: x,
            tl: /* [] */0
          };
  }
}

function initialize(length, f) {
  return Belt_List.makeBy(length, Curry.__1(f));
}

function forEach(t, f) {
  Belt_List.forEach(t, Curry.__1(f));
}

function forEachWithIndex(t, f) {
  Belt_List.forEachWithIndex(t, Curry.__2(f));
}

var toArray = $$Array.of_list;

function join(strings, sep) {
  return Js_array.joinWith(sep, $$Array.of_list(strings));
}

function groupBy(t, comparator, f) {
  return fold(t, TableclothMap.empty(comparator), (function (map, element) {
                var key = Curry._1(f, element);
                return TableclothMap.update(map, key, (function (x) {
                              if (x !== undefined) {
                                return {
                                        hd: element,
                                        tl: x
                                      };
                              } else {
                                return {
                                        hd: element,
                                        tl: /* [] */0
                                      };
                              }
                            }));
              }));
}

function equal(_a, _b, equalElement) {
  while(true) {
    var b = _b;
    var a = _a;
    if (!a) {
      if (b) {
        return false;
      } else {
        return true;
      }
    }
    if (!b) {
      return false;
    }
    if (!Curry._2(equalElement, a.hd, b.hd)) {
      return false;
    }
    _b = b.tl;
    _a = a.tl;
    continue ;
  };
}

function compare(_a, _b, compareElement) {
  while(true) {
    var b = _b;
    var a = _a;
    if (!a) {
      if (b) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!b) {
      return 1;
    }
    var result = Curry._2(compareElement, a.hd, b.hd);
    if (result !== 0) {
      return result;
    }
    _b = b.tl;
    _a = a.tl;
    continue ;
  };
}

var empty = /* [] */0;

export {
  empty ,
  singleton ,
  repeat ,
  range ,
  initialize ,
  fromArray ,
  head ,
  tail ,
  cons ,
  take ,
  takeWhile ,
  drop ,
  dropWhile ,
  initial ,
  last ,
  getAt ,
  insertAt ,
  updateAt ,
  removeAt ,
  reverse ,
  sort ,
  sortBy ,
  isEmpty ,
  length ,
  any ,
  all ,
  count ,
  uniqueBy ,
  find ,
  findIndex ,
  includes ,
  minimumBy ,
  maximumBy ,
  minimum ,
  maximum ,
  extent ,
  sum ,
  map ,
  mapWithIndex ,
  filter ,
  filterWithIndex ,
  filterMap ,
  flatMap ,
  fold ,
  foldRight ,
  append ,
  flatten ,
  zip ,
  map2 ,
  map3 ,
  partition ,
  splitAt ,
  splitWhen ,
  unzip ,
  forEach ,
  forEachWithIndex ,
  intersperse ,
  chunksOf ,
  sliding ,
  groupWhile ,
  join ,
  groupBy ,
  toArray ,
  equal ,
  compare ,
}
/* TableclothMap Not a pure module */

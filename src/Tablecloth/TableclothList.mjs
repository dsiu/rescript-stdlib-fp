// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Core__List from "@rescript/core/src/Core__List.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";
import * as TableclothMap from "./TableclothMap.mjs";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as Core__Ordering from "@rescript/core/src/Core__Ordering.mjs";

function singleton(x) {
  return {
          hd: x,
          tl: /* [] */0
        };
}

function range(fromOpt, to_) {
  var from = fromOpt !== undefined ? fromOpt : 0;
  if (to_ < from) {
    return /* [] */0;
  } else {
    return List.init(to_ - from | 0, (function (i) {
                  return i + from | 0;
                }));
  }
}

function repeat(element, times) {
  if (times <= 0) {
    return /* [] */0;
  } else {
    return {
            hd: element,
            tl: repeat(element, times - 1 | 0)
          };
  }
}

function sum(t, M) {
  return List.fold_left(M.add, M.zero, t);
}

function flatMap(t, f) {
  return Core__List.flat(Core__List.map(t, f));
}

function map2(a, b, f) {
  return Core__List.zipBy(a, b, f);
}

function map3(a, b, c, f) {
  if (a && b && c) {
    return {
            hd: f(a.hd, b.hd, c.hd),
            tl: map3(a.tl, b.tl, c.tl, f)
          };
  } else {
    return /* [] */0;
  }
}

function last(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    var rest = l.tl;
    if (!rest) {
      return Caml_option.some(l.hd);
    }
    _l = rest;
    continue ;
  };
}

function uniqueBy(l, f) {
  var _existing;
  var _remaining = l;
  var _accumulator = /* [] */0;
  while(true) {
    var accumulator = _accumulator;
    var remaining = _remaining;
    var existing = _existing;
    if (!remaining) {
      return Core__List.reverse(accumulator);
    }
    var rest = remaining.tl;
    var first = remaining.hd;
    var computedFirst = f(first);
    if (Belt_SetString.has(existing, computedFirst)) {
      _remaining = rest;
      continue ;
    }
    _accumulator = {
      hd: first,
      tl: accumulator
    };
    _remaining = rest;
    _existing = Belt_SetString.add(existing, computedFirst);
    continue ;
  };
}

var getAt = Belt_List.get;

function any(t, f) {
  return Core__Option.isSome(Core__List.find(t, f));
}

function initial(l) {
  var match = Core__List.reverse(l);
  if (match) {
    return Core__List.reverse(match.tl);
  }
  
}

function fold(t, initial, f) {
  return Core__List.reduce(t, initial, (function (a, b) {
                return f(a, b);
              }));
}

function count(t, f) {
  return fold(t, 0, (function (total, element) {
                return total + (
                        f(element) ? 1 : 0
                      ) | 0;
              }));
}

function foldRight(t, initial, f) {
  return Belt_List.reduceReverse(t, initial, (function (a, b) {
                return f(a, b);
              }));
}

function findIndex(list, f) {
  var _i = 0;
  var _l = list;
  while(true) {
    var l = _l;
    var i = _i;
    if (!l) {
      return ;
    }
    var x = l.hd;
    if (f(i, x)) {
      return [
              i,
              x
            ];
    }
    _l = l.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function updateAt(t, index, f) {
  return Belt_List.mapWithIndex(t, (function (i, element) {
                if (i === index) {
                  return f(element);
                } else {
                  return element;
                }
              }));
}

function dropWhile(_t, f) {
  while(true) {
    var t = _t;
    if (!t) {
      return /* [] */0;
    }
    if (!f(t.hd)) {
      return t;
    }
    _t = t.tl;
    continue ;
  };
}

function isEmpty(t) {
  return t === /* [] */0;
}

function sliding(stepOpt, t, size) {
  var step = stepOpt !== undefined ? stepOpt : 1;
  var loop = function (t) {
    if (t === /* [] */0) {
      return /* [] */0;
    }
    var sample = Belt_List.take(t, size);
    var rest = Belt_List.drop(t, step);
    if (sample !== undefined) {
      if (rest !== undefined) {
        return {
                hd: sample,
                tl: loop(rest)
              };
      } else {
        return {
                hd: sample,
                tl: /* [] */0
              };
      }
    } else {
      return /* [] */0;
    }
  };
  return loop(t);
}

function chunksOf(t, size) {
  return sliding(size, t, size);
}

function cons(t, element) {
  return {
          hd: element,
          tl: t
        };
}

function takeWhile(t, f) {
  var _acc = /* [] */0;
  var _t = t;
  while(true) {
    var t$1 = _t;
    var acc = _acc;
    if (!t$1) {
      return Core__List.reverse(acc);
    }
    var x = t$1.hd;
    if (!f(x)) {
      return Core__List.reverse(acc);
    }
    _t = t$1.tl;
    _acc = {
      hd: x,
      tl: acc
    };
    continue ;
  };
}

function removeAt(t, index) {
  if (index < 0) {
    return t;
  }
  var match = Core__List.splitAt(t, index);
  if (match === undefined) {
    return t;
  }
  var t$1 = Core__List.tail(match[1]);
  if (t$1 !== undefined) {
    return Core__List.concat(match[0], t$1);
  } else {
    return t;
  }
}

function minimumBy(l, f) {
  var minBy = function (param, x) {
    var fy = param[1];
    var fx = f(x);
    if (Caml_obj.lessthan(fx, fy)) {
      return [
              x,
              fx
            ];
    } else {
      return [
              param[0],
              fy
            ];
    }
  };
  if (!l) {
    return ;
  }
  var rest = l.tl;
  var x = l.hd;
  if (rest) {
    return Caml_option.some(fold(rest, [
                      x,
                      f(x)
                    ], minBy)[0]);
  } else {
    return Caml_option.some(x);
  }
}

function maximumBy(l, f) {
  var maxBy = function (param, x) {
    var fy = param[1];
    var fx = f(x);
    if (Caml_obj.greaterthan(fx, fy)) {
      return [
              x,
              fx
            ];
    } else {
      return [
              param[0],
              fy
            ];
    }
  };
  if (!l) {
    return ;
  }
  var rest = l.tl;
  var x = l.hd;
  if (rest) {
    return Caml_option.some(fold(rest, [
                      x,
                      f(x)
                    ], maxBy)[0]);
  } else {
    return Caml_option.some(x);
  }
}

function minimum(t, compare) {
  return fold(t, undefined, (function (min, element) {
                if (min !== undefined && !Core__Ordering.isLess(compare(element, Caml_option.valFromOption(min)))) {
                  return min;
                } else {
                  return Caml_option.some(element);
                }
              }));
}

function maximum(t, compare) {
  return fold(t, undefined, (function (max, element) {
                if (max !== undefined && !Core__Ordering.isGreater(compare(element, Caml_option.valFromOption(max)))) {
                  return max;
                } else {
                  return Caml_option.some(element);
                }
              }));
}

function extent(t, compare) {
  return fold(t, undefined, (function (current, element) {
                if (current === undefined) {
                  return [
                          element,
                          element
                        ];
                }
                var max = current[1];
                var min = current[0];
                return [
                        Core__Ordering.isLess(compare(element, min)) ? element : min,
                        Core__Ordering.isGreater(compare(element, max)) ? element : max
                      ];
              }));
}

function sortBy(l, f) {
  return Belt_List.sort(l, (function (a, b) {
                var a$p = f(a);
                var b$p = f(b);
                if (Caml_obj.equal(a$p, b$p)) {
                  return 0;
                } else if (Caml_obj.lessthan(a$p, b$p)) {
                  return -1;
                } else {
                  return 1;
                }
              }));
}

function groupWhile(l, f) {
  var $$break = function (param, x, y) {
    return f(x, y);
  };
  var groups = Belt_List.reduceWithIndex(l, /* [] */0, (function (acc, x, i) {
          if (!acc) {
            return {
                    hd: {
                      hd: x,
                      tl: /* [] */0
                    },
                    tl: /* [] */0
                  };
          }
          var tl = acc.tl;
          var current_group = acc.hd;
          if ($$break(i, Belt_List.headExn(current_group), x)) {
            return {
                    hd: {
                      hd: x,
                      tl: /* [] */0
                    },
                    tl: {
                      hd: current_group,
                      tl: tl
                    }
                  };
          } else {
            return {
                    hd: {
                      hd: x,
                      tl: current_group
                    },
                    tl: tl
                  };
          }
        }));
  if (groups) {
    return Belt_List.mapReverse(groups, Core__List.reverse);
  } else {
    return /* [] */0;
  }
}

function insertAt(t, index, value) {
  var match = Core__List.splitAt(t, index);
  if (match !== undefined) {
    return Core__List.concat(match[0], {
                hd: value,
                tl: match[1]
              });
  } else {
    return t;
  }
}

function splitWhen(t, f) {
  var _front = /* [] */0;
  var _back = t;
  while(true) {
    var back = _back;
    var front = _front;
    if (!back) {
      return [
              t,
              /* [] */0
            ];
    }
    var element = back.hd;
    if (f(element)) {
      return [
              Core__List.reverse(front),
              back
            ];
    }
    _back = back.tl;
    _front = {
      hd: element,
      tl: front
    };
    continue ;
  };
}

function intersperse(t, sep) {
  if (!t) {
    return /* [] */0;
  }
  var rest = t.tl;
  var x = t.hd;
  if (rest) {
    return {
            hd: x,
            tl: foldRight(rest, /* [] */0, (function (acc, x) {
                    return {
                            hd: sep,
                            tl: {
                              hd: x,
                              tl: acc
                            }
                          };
                  }))
          };
  } else {
    return {
            hd: x,
            tl: /* [] */0
          };
  }
}

function initialize(length, f) {
  return Core__List.fromInitializer(length, (function (a) {
                return f(a);
              }));
}

function join(strings, sep) {
  return Core__List.toArray(strings).join(sep);
}

function groupBy(t, comparator, f) {
  return fold(t, TableclothMap.empty(comparator), (function (map, element) {
                var key = f(element);
                return TableclothMap.update(map, key, (function (x) {
                              if (x !== undefined) {
                                return {
                                        hd: element,
                                        tl: x
                                      };
                              } else {
                                return {
                                        hd: element,
                                        tl: /* [] */0
                                      };
                              }
                            }));
              }));
}

var empty = /* [] */0;

var take = Core__List.take;

var drop = Core__List.drop;

var all = Core__List.every;

var find = Core__List.find;

var includes = Core__List.has;

var append = Core__List.concat;

export {
  empty ,
  singleton ,
  repeat ,
  range ,
  initialize ,
  cons ,
  take ,
  takeWhile ,
  drop ,
  dropWhile ,
  initial ,
  last ,
  getAt ,
  insertAt ,
  updateAt ,
  removeAt ,
  sortBy ,
  isEmpty ,
  any ,
  all ,
  count ,
  uniqueBy ,
  find ,
  findIndex ,
  includes ,
  minimumBy ,
  maximumBy ,
  minimum ,
  maximum ,
  extent ,
  sum ,
  flatMap ,
  fold ,
  foldRight ,
  append ,
  map2 ,
  map3 ,
  splitWhen ,
  intersperse ,
  chunksOf ,
  sliding ,
  groupWhile ,
  join ,
  groupBy ,
}
/* TableclothMap Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/List.js";
import * as Option from "rescript/lib/es6/Option.js";
import * as Ordering from "rescript/lib/es6/Ordering.js";
import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as TableclothMap from "./TableclothMap.mjs";
import * as Belt_SetString from "rescript/lib/es6/Belt_SetString.js";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function singleton(x) {
  return {
    hd: x,
    tl: /* [] */0
  };
}

function range(fromOpt, to_) {
  let from = fromOpt !== undefined ? fromOpt : 0;
  if (to_ < from) {
    return /* [] */0;
  } else {
    return List.fromInitializer(to_ - from | 0, i => i + from | 0);
  }
}

function repeat(element, times) {
  if (times <= 0) {
    return /* [] */0;
  } else {
    return {
      hd: element,
      tl: repeat(element, times - 1 | 0)
    };
  }
}

function sum(t, M) {
  return List.reduce(t, M.zero, M.add);
}

function flatMap(t, f) {
  return List.flat(List.map(t, f));
}

let map2 = List.zipBy;

function map3(a, b, c, f) {
  if (a && b && c) {
    return {
      hd: f(a.hd, b.hd, c.hd),
      tl: map3(a.tl, b.tl, c.tl, f)
    };
  } else {
    return /* [] */0;
  }
}

function last(_l) {
  while (true) {
    let l = _l;
    if (!l) {
      return;
    }
    let rest = l.tl;
    if (!rest) {
      return Primitive_option.some(l.hd);
    }
    _l = rest;
    continue;
  };
}

function uniqueBy(l, f) {
  let _existing;
  let _remaining = l;
  let _accumulator = /* [] */0;
  while (true) {
    let accumulator = _accumulator;
    let remaining = _remaining;
    let existing = _existing;
    if (!remaining) {
      return List.reverse(accumulator);
    }
    let rest = remaining.tl;
    let first = remaining.hd;
    let computedFirst = f(first);
    if (Belt_SetString.has(existing, computedFirst)) {
      _remaining = rest;
      continue;
    }
    _accumulator = {
      hd: first,
      tl: accumulator
    };
    _remaining = rest;
    _existing = Belt_SetString.add(existing, computedFirst);
    continue;
  };
}

let getAt = Belt_List.get;

function any(t, f) {
  return Option.isSome(List.find(t, f));
}

function initial(l) {
  let match = List.reverse(l);
  if (match) {
    return List.reverse(match.tl);
  }
  
}

function fold(t, initial, f) {
  return List.reduce(t, initial, (a, b) => f(a, b));
}

function count(t, f) {
  return fold(t, 0, (total, element) => total + (
    f(element) ? 1 : 0
  ) | 0);
}

function foldRight(t, initial, f) {
  return Belt_List.reduceReverse(t, initial, (a, b) => f(a, b));
}

function findIndex(list, f) {
  let _i = 0;
  let _l = list;
  while (true) {
    let l = _l;
    let i = _i;
    if (!l) {
      return;
    }
    let x = l.hd;
    if (f(i, x)) {
      return [
        i,
        x
      ];
    }
    _l = l.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function updateAt(t, index, f) {
  return Belt_List.mapWithIndex(t, (i, element) => {
    if (i === index) {
      return f(element);
    } else {
      return element;
    }
  });
}

function dropWhile(_t, f) {
  while (true) {
    let t = _t;
    if (!t) {
      return /* [] */0;
    }
    if (!f(t.hd)) {
      return t;
    }
    _t = t.tl;
    continue;
  };
}

function isEmpty(t) {
  return t === /* [] */0;
}

function sliding(stepOpt, t, size) {
  let step = stepOpt !== undefined ? stepOpt : 1;
  let loop = t => {
    if (t === /* [] */0) {
      return /* [] */0;
    }
    let sample = Belt_List.take(t, size);
    let rest = Belt_List.drop(t, step);
    if (sample !== undefined) {
      if (rest !== undefined) {
        return {
          hd: sample,
          tl: loop(rest)
        };
      } else {
        return {
          hd: sample,
          tl: /* [] */0
        };
      }
    } else {
      return /* [] */0;
    }
  };
  return loop(t);
}

function chunksOf(t, size) {
  return sliding(size, t, size);
}

function cons(t, element) {
  return {
    hd: element,
    tl: t
  };
}

function takeWhile(t, f) {
  let _acc = /* [] */0;
  let _t = t;
  while (true) {
    let t$1 = _t;
    let acc = _acc;
    if (!t$1) {
      return List.reverse(acc);
    }
    let x = t$1.hd;
    if (!f(x)) {
      return List.reverse(acc);
    }
    _t = t$1.tl;
    _acc = {
      hd: x,
      tl: acc
    };
    continue;
  };
}

function removeAt(t, index) {
  if (index < 0) {
    return t;
  }
  let match = List.splitAt(t, index);
  if (match === undefined) {
    return t;
  }
  let t$1 = List.tail(match[1]);
  if (t$1 !== undefined) {
    return List.concat(match[0], t$1);
  } else {
    return t;
  }
}

function minimumBy(l, f) {
  let minBy = (param, x) => {
    let fy = param[1];
    let fx = f(x);
    if (Primitive_object.lessthan(fx, fy)) {
      return [
        x,
        fx
      ];
    } else {
      return [
        param[0],
        fy
      ];
    }
  };
  if (!l) {
    return;
  }
  let rest = l.tl;
  let x = l.hd;
  if (rest) {
    return Primitive_option.some(fold(rest, [
        x,
        f(x)
      ], minBy)[0]);
  } else {
    return Primitive_option.some(x);
  }
}

function maximumBy(l, f) {
  let maxBy = (param, x) => {
    let fy = param[1];
    let fx = f(x);
    if (Primitive_object.greaterthan(fx, fy)) {
      return [
        x,
        fx
      ];
    } else {
      return [
        param[0],
        fy
      ];
    }
  };
  if (!l) {
    return;
  }
  let rest = l.tl;
  let x = l.hd;
  if (rest) {
    return Primitive_option.some(fold(rest, [
        x,
        f(x)
      ], maxBy)[0]);
  } else {
    return Primitive_option.some(x);
  }
}

function minimum(t, compare) {
  return fold(t, undefined, (min, element) => {
    if (min !== undefined && !Ordering.isLess(compare(element, Primitive_option.valFromOption(min)))) {
      return min;
    } else {
      return Primitive_option.some(element);
    }
  });
}

function maximum(t, compare) {
  return fold(t, undefined, (max, element) => {
    if (max !== undefined && !Ordering.isGreater(compare(element, Primitive_option.valFromOption(max)))) {
      return max;
    } else {
      return Primitive_option.some(element);
    }
  });
}

function extent(t, compare) {
  return fold(t, undefined, (current, element) => {
    if (current === undefined) {
      return [
        element,
        element
      ];
    }
    let max = current[1];
    let min = current[0];
    return [
      Ordering.isLess(compare(element, min)) ? element : min,
      Ordering.isGreater(compare(element, max)) ? element : max
    ];
  });
}

function sortBy(l, f) {
  return Belt_List.sort(l, (a, b) => {
    let a$p = f(a);
    let b$p = f(b);
    if (Primitive_object.equal(a$p, b$p)) {
      return 0;
    } else if (Primitive_object.lessthan(a$p, b$p)) {
      return -1;
    } else {
      return 1;
    }
  });
}

function groupWhile(l, f) {
  let $$break = (param, x, y) => f(x, y);
  let groups = Belt_List.reduceWithIndex(l, /* [] */0, (acc, x, i) => {
    if (!acc) {
      return {
        hd: {
          hd: x,
          tl: /* [] */0
        },
        tl: /* [] */0
      };
    }
    let tl = acc.tl;
    let current_group = acc.hd;
    if ($$break(i, Belt_List.headExn(current_group), x)) {
      return {
        hd: {
          hd: x,
          tl: /* [] */0
        },
        tl: {
          hd: current_group,
          tl: tl
        }
      };
    } else {
      return {
        hd: {
          hd: x,
          tl: current_group
        },
        tl: tl
      };
    }
  });
  if (groups) {
    return Belt_List.mapReverse(groups, List.reverse);
  } else {
    return /* [] */0;
  }
}

function insertAt(t, index, value) {
  let match = List.splitAt(t, index);
  if (match !== undefined) {
    return List.concat(match[0], {
      hd: value,
      tl: match[1]
    });
  } else {
    return t;
  }
}

function splitWhen(t, f) {
  let _front = /* [] */0;
  let _back = t;
  while (true) {
    let back = _back;
    let front = _front;
    if (!back) {
      return [
        t,
        /* [] */0
      ];
    }
    let element = back.hd;
    if (f(element)) {
      return [
        List.reverse(front),
        back
      ];
    }
    _back = back.tl;
    _front = {
      hd: element,
      tl: front
    };
    continue;
  };
}

function intersperse(t, sep) {
  if (!t) {
    return /* [] */0;
  }
  let rest = t.tl;
  let x = t.hd;
  if (rest) {
    return {
      hd: x,
      tl: foldRight(rest, /* [] */0, (acc, x) => ({
        hd: sep,
        tl: {
          hd: x,
          tl: acc
        }
      }))
    };
  } else {
    return {
      hd: x,
      tl: /* [] */0
    };
  }
}

function initialize(length, f) {
  return List.fromInitializer(length, a => f(a));
}

function join(strings, sep) {
  return List.toArray(strings).join(sep);
}

function groupBy(t, comparator, f) {
  return fold(t, TableclothMap.empty(comparator), (map, element) => {
    let key = f(element);
    return TableclothMap.update(map, key, x => {
      if (x !== undefined) {
        return {
          hd: element,
          tl: x
        };
      } else {
        return {
          hd: element,
          tl: /* [] */0
        };
      }
    });
  });
}

let empty = /* [] */0;

let take = List.take;

let drop = List.drop;

let all = List.every;

let find = List.find;

let includes = List.has;

let append = List.concat;

export {
  empty,
  singleton,
  repeat,
  range,
  initialize,
  cons,
  take,
  takeWhile,
  drop,
  dropWhile,
  initial,
  last,
  getAt,
  insertAt,
  updateAt,
  removeAt,
  sortBy,
  isEmpty,
  any,
  all,
  count,
  uniqueBy,
  find,
  findIndex,
  includes,
  minimumBy,
  maximumBy,
  minimum,
  maximum,
  extent,
  sum,
  flatMap,
  fold,
  foldRight,
  append,
  map2,
  map3,
  splitWhen,
  intersperse,
  chunksOf,
  sliding,
  groupWhile,
  join,
  groupBy,
}
/* TableclothMap Not a pure module */

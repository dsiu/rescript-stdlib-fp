// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Map from "rescript/lib/es6/Belt_Map.js";
import * as Internal from "./Internal.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Core__List from "@rescript/core/src/Core__List.mjs";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as TableclothOption from "./TableclothOption.mjs";

function fromArray(comparator, values) {
  return Belt_Map.fromArray(values, Internal.toBeltComparator(comparator));
}

function empty(comparator) {
  return Belt_Map.fromArray([], Internal.toBeltComparator(comparator));
}

function fromList(comparator, l) {
  let values = Core__List.toArray(l);
  return Belt_Map.fromArray(values, Internal.toBeltComparator(comparator));
}

function singleton(comparator, key, value) {
  return Belt_Map.fromArray([[
      key,
      value
    ]], Internal.toBeltComparator(comparator));
}

let isEmpty = Belt_Map.isEmpty;

let includes = Belt_Map.has;

let length = Belt_Map.size;

let add = Belt_Map.set;

let remove = Belt_Map.remove;

let get = Belt_Map.get;

function update(m, key, f) {
  return Belt_Map.update(m, key, a => f(a));
}

function merge(m1, m2, f) {
  return Belt_Map.merge(m1, m2, (m, a, b) => f(m, a, b));
}

function map(m, f) {
  return Belt_Map.map(m, value => f(value));
}

function mapWithIndex(t, f) {
  return Belt_Map.mapWithKey(t, (a, b) => f(a, b));
}

function filter(m, f) {
  return Belt_Map.keep(m, (param, value) => f(value));
}

function filterMap(m, f) {
  let f$p = param => {
    let key = param[0];
    return Belt_Option.map(f(key, param[1]), value$p => [
      key,
      value$p
    ]);
  };
  return Belt_Map.fromArray(Belt_Array.keepMap(Belt_Map.toArray(m), f$p), Belt_Map.getId(m));
}

function partition(m, f) {
  return Belt_Map.partition(m, (key, value) => f(key, value));
}

function find(m, f) {
  return Belt_Map.findFirstBy(m, (key, value) => f(key, value));
}

function any(m, f) {
  return Belt_Map.some(m, (param, value) => f(value));
}

function all(m, f) {
  return Belt_Map.every(m, (param, value) => f(value));
}

function forEach(m, f) {
  Belt_Map.forEach(m, (param, value) => f(value));
}

function forEachWithIndex(m, f) {
  Belt_Map.forEach(m, (key, value) => f(key, value));
}

function fold(m, initial, f) {
  return Belt_Map.reduce(m, initial, (acc, key, data) => f(acc, key, data));
}

function keys(m) {
  return Core__List.fromArray(Belt_Map.keysToArray(m));
}

function values(m) {
  return Core__List.fromArray(Belt_Map.valuesToArray(m));
}

let maximum = Belt_Map.maxKey;

let minimum = Belt_Map.minKey;

function extent(t) {
  return TableclothOption.both(Belt_Map.minKey(t), Belt_Map.maxKey(t));
}

let toArray = Belt_Map.toArray;

let toList = Belt_Map.toList;

function fromArray$1(a) {
  let cmp = Primitive_object.compare;
  return Belt_Map.fromArray(a, {
    cmp: cmp
  });
}

function empty$1() {
  return fromArray$1([]);
}

function fromList$1(l) {
  return fromArray$1(Core__List.toArray(l));
}

function singleton$1(key, value) {
  return fromArray$1([[
      key,
      value
    ]]);
}

let fromArray$2 = fromArray$1;

let empty$2 = fromArray$1([]);

function singleton$2(key, value) {
  return fromArray$1([[
      key,
      value
    ]]);
}

function fromList$2(l) {
  return fromArray$1(Core__List.toArray(l));
}

let fromArray$3 = fromArray$1;

let empty$3 = fromArray$1([]);

function singleton$3(key, value) {
  return fromArray$1([[
      key,
      value
    ]]);
}

function fromList$3(l) {
  return fromArray$1(Core__List.toArray(l));
}

let Poly = {
  empty: empty$1,
  singleton: singleton$1,
  fromArray: fromArray$1,
  fromList: fromList$1
};

let Int = {
  empty: empty$2,
  singleton: singleton$2,
  fromArray: fromArray$2,
  fromList: fromList$2
};

let $$String = {
  empty: empty$3,
  singleton: singleton$3,
  fromArray: fromArray$3,
  fromList: fromList$3
};

export {
  empty,
  singleton,
  fromArray,
  fromList,
  add,
  remove,
  get,
  update,
  isEmpty,
  length,
  any,
  all,
  find,
  includes,
  minimum,
  maximum,
  extent,
  merge,
  map,
  mapWithIndex,
  filter,
  filterMap,
  partition,
  fold,
  forEach,
  forEachWithIndex,
  keys,
  values,
  toArray,
  toList,
  Poly,
  Int,
  $$String,
}
/* empty Not a pure module */

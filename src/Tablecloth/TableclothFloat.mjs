// Generated by ReScript, PLEASE EDIT WITH CARE


function add(prim0, prim1) {
  return prim0 + prim1;
}

function subtract(prim0, prim1) {
  return prim0 - prim1;
}

function multiply(prim0, prim1) {
  return prim0 * prim1;
}

function divide(n, by) {
  return n / by;
}

function negate(prim) {
  return - prim;
}

function inRange(n, lower, upper) {
  if (upper < lower) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "~lower:" + (lower.toString() + (" must be less than or equal to ~upper:" + upper.toString())),
          Error: new Error()
        };
  }
  if (n >= lower) {
    return n < upper;
  } else {
    return false;
  }
}

function log(n, base) {
  return Math.log(n) / Math.log(base);
}

function isInfinite(n) {
  if (isFinite(n)) {
    return false;
  } else {
    return !isNaN(n);
  }
}

function degrees(n) {
  return n * (Math.PI / 180.0);
}

function turns(n) {
  return n * 2 * Math.PI;
}

function round(directionOpt, n) {
  var direction = directionOpt !== undefined ? directionOpt : ({
        NAME: "Closest",
        VAL: "Up"
      });
  if (typeof direction !== "object") {
    if (direction === "Down") {
      return Math.floor(n);
    } else if (direction === "AwayFromZero") {
      if (n > 0) {
        return Math.ceil(n);
      } else {
        return Math.floor(n);
      }
    } else if (direction === "Zero") {
      return Math.trunc(n);
    } else {
      return Math.ceil(n);
    }
  }
  var match = direction.VAL;
  if (match === "Down") {
    return Math.ceil(n - 0.5);
  }
  if (match !== "ToEven") {
    if (match === "AwayFromZero") {
      if (n > 0) {
        return Math.floor(n + 0.5);
      } else {
        return Math.ceil(n - 0.5);
      }
    } else if (match === "Zero") {
      if (n > 0) {
        return Math.ceil(n - 0.5);
      } else {
        return Math.floor(n + 0.5);
      }
    } else {
      return Math.round(n);
    }
  }
  var roundNearestLowerBound = - Math.pow(2, 52);
  var roundNearestUpperBound = Math.pow(2, 52);
  if (n <= roundNearestLowerBound || n >= roundNearestUpperBound) {
    return n + 0;
  }
  var floor = Math.floor(n);
  var ceil_or_succ = floor + 1;
  var diff_floor = n - floor;
  var diff_ceil = ceil_or_succ - n;
  if (diff_floor < diff_ceil || !(diff_floor > diff_ceil || floor % 2 !== 0)) {
    return floor;
  } else {
    return ceil_or_succ;
  }
}

function fromPolar(param) {
  var theta = param[1];
  var r = param[0];
  return [
          r * Math.cos(theta),
          r * Math.sin(theta)
        ];
}

function toPolar(param) {
  var y = param[1];
  var x = param[0];
  return [
          Math.hypot(x, y),
          Math.atan2(y, x)
        ];
}

var zero = 0.0;

var one = 1.0;

var maximumSafeInteger = Number.MAX_SAFE_INTEGER;

var minimumSafeInteger = Number.MIN_SAFE_INTEGER;

function isInteger(prim) {
  return Number.isInteger(prim);
}

function isSafeInteger(prim) {
  return Number.isSafeInteger(prim);
}

function radians(prim) {
  return prim;
}

export {
  zero ,
  one ,
  maximumSafeInteger ,
  minimumSafeInteger ,
  add ,
  subtract ,
  multiply ,
  divide ,
  negate ,
  log ,
  isInfinite ,
  isInteger ,
  isSafeInteger ,
  inRange ,
  degrees ,
  radians ,
  turns ,
  fromPolar ,
  toPolar ,
  round ,
}
/* maximumSafeInteger Not a pure module */

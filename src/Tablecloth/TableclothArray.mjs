// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Array from "rescript/lib/es6/Array.js";
import * as Option from "rescript/lib/es6/Option.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Core__List from "@rescript/core/src/Core__List.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as TableclothMap from "./TableclothMap.mjs";
import * as Core__Ordering from "@rescript/core/src/Core__Ordering.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function singleton(a) {
  return [a];
}

function clone(t) {
  return t.map(prim => prim);
}

function isEmpty(a) {
  return a.length === 0;
}

let initialize = Core__Array.fromInitializer;

function range(fromOpt, to_) {
  let from = fromOpt !== undefined ? fromOpt : 0;
  return Core__Array.fromInitializer(to_ - from | 0, i => i + from | 0);
}

function toIndexedList(array) {
  return Core__Array.reduceRight(array, [
      array.length - 1 | 0,
      /* [] */0
    ], (param, x) => {
      let i = param[0];
      return [
        i - 1 | 0,
        {
          hd: [
            i,
            x
          ],
          tl: param[1]
        }
      ];
    })[1];
}

function getUnsafe(prim0, prim1) {
  return prim0[prim1];
}

function first(__x) {
  return __x[0];
}

function setUnsafe(prim0, prim1, prim2) {
  prim0[prim1] = prim2;
}

function swap(t, i, j) {
  let temp = Option.getExn(t[i], undefined);
  t[i] = Option.getExn(t[j], undefined);
  t[j] = temp;
}

function fold(t, initial, f) {
  return Core__Array.reduce(t, initial, (a, b) => f(a, b));
}

function foldRight(t, initial, f) {
  return Core__Array.reduceRight(t, initial, (a, b) => f(a, b));
}

function maximum(t, compare) {
  return fold(t, undefined, (max, element) => {
    if (max !== undefined && !Core__Ordering.isGreater(compare(element, Primitive_option.valFromOption(max)))) {
      return max;
    } else {
      return Primitive_option.some(element);
    }
  });
}

function minimum(t, compare) {
  return fold(t, undefined, (min, element) => {
    if (min !== undefined && !Core__Ordering.isLess(compare(element, Primitive_option.valFromOption(min)))) {
      return min;
    } else {
      return Primitive_option.some(element);
    }
  });
}

function extent(t, compare) {
  return fold(t, undefined, (range, element) => {
    if (range === undefined) {
      return [
        element,
        element
      ];
    }
    let max = range[1];
    let min = range[0];
    return [
      Core__Ordering.isLess(compare(element, min)) ? element : min,
      Core__Ordering.isGreater(compare(element, max)) ? element : max
    ];
  });
}

function sum(t, M) {
  return $$Array.reduce(t, M.zero, M.add);
}

let map2 = Belt_Array.zipBy;

function map3(as_, bs, cs, f) {
  let minLength = Core__Array.reduce([
    bs.length,
    cs.length
  ], as_.length, Primitive_int.min);
  return Core__Array.fromInitializer(minLength, i => f(Option.getExn(as_[i], undefined), Option.getExn(bs[i], undefined), Option.getExn(cs[i], undefined)));
}

function zip(a, b) {
  return Belt_Array.zipBy(a, b, (a, b) => [
    a,
    b
  ]);
}

function sliding(stepOpt, a, size) {
  let step = stepOpt !== undefined ? stepOpt : 1;
  let n = a.length;
  if (size > n) {
    return [];
  } else {
    return Core__Array.fromInitializer(1 + Primitive_int.div(n - size | 0, step) | 0, i => Core__Array.fromInitializer(size, j => Option.getExn(a[Math.imul(i, step) + j | 0], undefined)));
  }
}

function find(t, f) {
  let length = t.length;
  let _i = 0;
  while (true) {
    let i = _i;
    if (i >= length) {
      return;
    }
    if (f(Option.getExn(t[i], undefined))) {
      return Primitive_option.some(Option.getExn(t[i], undefined));
    }
    _i = i + 1 | 0;
    continue;
  };
}

function findIndex(array, f) {
  let _index = 0;
  while (true) {
    let index = _index;
    if (index >= array.length) {
      return;
    }
    if (f(index, Option.getExn(array[index], undefined))) {
      return [
        index,
        Option.getExn(array[index], undefined)
      ];
    }
    _index = index + 1 | 0;
    continue;
  };
}

function any(prim0, prim1) {
  return prim0.some(prim1);
}

function all(prim0, prim1) {
  return prim0.every(prim1);
}

function includes(t, v, equal) {
  return t.some(__x => equal(v, __x));
}

function append(prim0, prim1) {
  return prim0.concat(prim1);
}

function flatten(prim) {
  return prim.flat();
}

function intersperse(t, sep) {
  return Core__Array.fromInitializer(Primitive_int.max(0, (t.length << 1) - 1 | 0), i => {
    if (i % 2 !== 0) {
      return sep;
    } else {
      return Option.getExn(t[i / 2 | 0], undefined);
    }
  });
}

function count(t, f) {
  return fold(t, 0, (total, element) => total + (
    f(element) ? 1 : 0
  ) | 0);
}

function chunksOf(t, size) {
  return sliding(size, t, size);
}

function partition(t, f) {
  let match = foldRight(t, [
    /* [] */0,
    /* [] */0
  ], (param, element) => {
    let rights = param[1];
    let lefts = param[0];
    if (f(element)) {
      return [
        {
          hd: element,
          tl: lefts
        },
        rights
      ];
    } else {
      return [
        lefts,
        {
          hd: element,
          tl: rights
        }
      ];
    }
  });
  return [
    Core__List.toArray(match[0]),
    Core__List.toArray(match[1])
  ];
}

function splitAt(t, index) {
  return [
    t.slice(0, index),
    t.slice(index, t.length)
  ];
}

function splitWhen(t, f) {
  let match = findIndex(t, (param, e) => f(e));
  if (match !== undefined) {
    return splitAt(t, match[0]);
  } else {
    return [
      t,
      []
    ];
  }
}

function unzip(t) {
  return [
    Core__Array.fromInitializer(t.length, i => Option.getExn(t[i], undefined)[0]),
    Core__Array.fromInitializer(t.length, i => Option.getExn(t[i], undefined)[1])
  ];
}

function repeat(element, length) {
  return Core__Array.fromInitializer(Primitive_int.max(length, 0), param => element);
}

function groupBy(t, comparator, f) {
  return fold(t, TableclothMap.empty(comparator), (map, element) => {
    let key = f(element);
    return TableclothMap.update(map, key, x => {
      if (x !== undefined) {
        return {
          hd: element,
          tl: x
        };
      } else {
        return {
          hd: element,
          tl: /* [] */0
        };
      }
    });
  });
}

let filterMap = Core__Array.filterMap;

let values = Core__Array.keepSome;

let equal = Core__Array.equal;

export {
  singleton,
  repeat,
  range,
  initialize,
  clone,
  getUnsafe,
  setUnsafe,
  first,
  swap,
  isEmpty,
  any,
  all,
  count,
  find,
  findIndex,
  includes,
  minimum,
  maximum,
  extent,
  sum,
  filterMap,
  fold,
  foldRight,
  append,
  flatten,
  zip,
  map2,
  map3,
  partition,
  splitAt,
  splitWhen,
  unzip,
  values,
  intersperse,
  chunksOf,
  sliding,
  groupBy,
  toIndexedList,
  equal,
}
/* TableclothMap Not a pure module */

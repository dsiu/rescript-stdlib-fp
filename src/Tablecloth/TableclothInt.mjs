// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_int from "rescript/lib/es6/js_int.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_format from "rescript/lib/es6/caml_format.js";
import * as TableclothFloat from "./TableclothFloat.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as TableclothComparator from "./TableclothComparator.mjs";

var compare = Caml_obj.compare;

var include = TableclothComparator.Make({
      compare: compare
    });

function fromString(s) {
  var i;
  try {
    i = Caml_format.int_of_string(s);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
  return i;
}

function add(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function subtract(prim0, prim1) {
  return prim0 - prim1 | 0;
}

function multiply(prim0, prim1) {
  return Math.imul(prim0, prim1);
}

var divide = Caml_int32.div;

function divideFloat(n, by) {
  return n / by;
}

function power(base, exponent) {
  var result = Math.pow(base, exponent);
  return Math.trunc(result > TableclothFloat.maximumSafeInteger ? TableclothFloat.maximumSafeInteger : (
                result < TableclothFloat.minimumSafeInteger ? TableclothFloat.minimumSafeInteger : result
              ));
}

function negate(prim) {
  return -prim | 0;
}

var remainder = Caml_int32.mod_;

function modulo(n, by) {
  return Caml_int32.mod_(n <= 0 ? (Pervasives.abs(n) << 1) : n, by);
}

function maximum(a, b) {
  return Math.max(a, b);
}

function minimum(a, b) {
  return Math.min(a, b);
}

function isEven(n) {
  return n % 2 === 0;
}

function isOdd(n) {
  return n % 2 !== 0;
}

function clamp(n, lower, upper) {
  if (Caml_obj.lessthan(upper, lower)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "~lower must be less than or equal to ~upper",
          Error: new Error()
        };
  }
  return Caml_obj.max(lower, Caml_obj.min(upper, n));
}

function inRange(n, lower, upper) {
  if (Caml_obj.lessthan(upper, lower)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "~lower must be less than or equal to ~upper",
          Error: new Error()
        };
  }
  if (Caml_obj.greaterequal(n, lower)) {
    return Caml_obj.lessthan(n, upper);
  } else {
    return false;
  }
}

function toFloat(t) {
  return t;
}

function toString(t) {
  return t.toString();
}

var equal = Caml_obj.equal;

var compare$1 = Caml_obj.compare;

var zero = 0;

var one = 1;

var maximumValue = Js_int.max;

var minimumValue = Js_int.min;

var absolute = Pervasives.abs;

var comparator = include.comparator;

export {
  zero ,
  one ,
  maximumValue ,
  minimumValue ,
  fromString ,
  add ,
  subtract ,
  multiply ,
  divide ,
  divideFloat ,
  power ,
  negate ,
  absolute ,
  modulo ,
  remainder ,
  maximum ,
  minimum ,
  isEven ,
  isOdd ,
  clamp ,
  inRange ,
  toFloat ,
  toString ,
  equal ,
  compare$1 as compare,
  comparator ,
}
/* include Not a pure module */

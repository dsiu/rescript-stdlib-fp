// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as TableclothArray from "./Tablecloth/TableclothArray.mjs";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function append(prim0, prim1) {
  return prim0.concat(prim1);
}

function headUnsafe(xs) {
  return xs[0];
}

function lastUnsafe(xs) {
  return xs[xs.length - 1 | 0];
}

function tail(__x) {
  return __x.slice(1);
}

function init(xs) {
  let l = xs.length;
  if (l === 0) {
    return;
  } else {
    return xs.slice(0, l - 1 | 0);
  }
}

function uncons(xs) {
  if (xs.length !== 0) {
    return [
      xs[0],
      xs.slice(1)
    ];
  }
  
}

function singleton(__x) {
  return Core__Array.make(1, __x);
}

function take(xs, n) {
  let l = xs.length;
  let len = n < 0 ? 0 : (
      l < n ? l : n
    );
  return xs.slice(0, len);
}

function takeExactly(xs, n) {
  if (n < 0 || n > xs.length) {
    return;
  } else {
    return xs.slice(0, n);
  }
}

function takeWhile(xs, predicateFn) {
  return Core__Array.reduce(xs, [], (acc, element) => {
    if (predicateFn(element)) {
      acc.push(element);
    }
    return acc;
  });
}

function drop(xs, n) {
  let l = xs.length;
  let start = n < 0 ? 0 : (
      l < n ? l : n
    );
  return xs.slice(start);
}

function dropExactly(xs, n) {
  if (n < 0 || n > xs.length) {
    return;
  } else {
    return xs.slice(n);
  }
}

function dropWhile(xs, predicateFn) {
  return Core__Array.reduce(xs, [], (acc, element) => {
    if (!predicateFn(element)) {
      acc.push(element);
    }
    return acc;
  });
}

function tails(xs) {
  if (xs.length === 0) {
    return [[]];
  } else {
    return [xs].concat(tails(xs.slice(1)));
  }
}

function uniqBy(xs, uniqFn) {
  let index = 0;
  let arr = [];
  while (index < xs.length) {
    let value = xs[index];
    let alreadyAdded = arr.some(x => Primitive_object.equal(uniqFn(x), uniqFn(value)));
    if (!alreadyAdded) {
      arr.push(value);
    }
    index = index + 1 | 0;
  };
  return arr;
}

function uniq(xs) {
  return uniqBy(xs, prim => prim);
}

function scanl(xs, initial, fn) {
  let tmp;
  if (xs.length === 0) {
    tmp = [];
  } else {
    let h = xs[0];
    let tails = xs.slice(1);
    tmp = scanl(tails, fn(initial, h), fn);
  }
  return [initial].concat(tmp);
}

function arrayToOption(__x) {
  return __x[0];
}

function foldl1(xs, f) {
  let init = xs[0];
  let rest = xs.slice(1);
  return Core__Array.reduce(rest, init, f);
}

function foldr1(xs, f) {
  let end = xs.length - 1 | 0;
  let init = xs[end];
  let rest = xs.slice(0, end);
  return Core__Array.reduceRight(rest, init, f);
}

function unfoldr(initial, f) {
  let _acc = [];
  let _seed = initial;
  while (true) {
    let seed = _seed;
    let acc = _acc;
    let match = f(seed);
    if (match === undefined) {
      return acc;
    }
    _seed = match[1];
    _acc = Belt_Array.concatMany([
      acc,
      [match[0]]
    ]);
    continue;
  };
}

function $$return(x) {
  return [x];
}

function transpose(_a) {
  while (true) {
    let a = _a;
    if (a.length === 0) {
      return [];
    }
    let h = a[0];
    let xss = a.slice(1);
    if (TableclothArray.isEmpty(h)) {
      _a = xss;
      continue;
    }
    let x = h[0];
    let xs = h.slice(1);
    let match = TableclothArray.unzip(xss.map(y => [
      y[0],
      y.slice(1)
    ]));
    return Belt_Array.concatMany([
      [[Belt_Array.concatMany([
            [x],
            match[0]
          ])]],
      transpose(Belt_Array.concatMany([
        [xs],
        match[1]
      ]))
    ]);
  };
}

function liftM2(f, m1, m2) {
  return m1.flatMap(x1 => m2.flatMap(x2 => [f(x1, x2)]));
}

function combinationIf2(a, b, f) {
  let ret = {
    contents: []
  };
  a.forEach(x => {
    b.forEach(y => {
      let r = f(x, y);
      if (r !== undefined) {
        ret.contents = ret.contents.concat([Primitive_option.valFromOption(r)]);
        return;
      }
      
    });
  });
  return ret.contents;
}

function combination2(a, b, f) {
  return combinationIf2(a, b, (x, y) => Primitive_option.some(f(x, y)));
}

function combinationIf3(a, b, c, f) {
  let ret = {
    contents: []
  };
  a.forEach(x => {
    b.forEach(y => {
      c.forEach(z => {
        let r = f(x, y, z);
        if (r !== undefined) {
          ret.contents = ret.contents.concat([Primitive_option.valFromOption(r)]);
          return;
        }
        
      });
    });
  });
  return ret.contents;
}

function combinationArray3(a, b, c, f) {
  return combinationIf3(a, b, c, (x, y, z) => Primitive_option.some(f(x, y, z)));
}

function combinationIf4(a, b, c, d, f) {
  let ret = {
    contents: []
  };
  a.forEach(x => {
    b.forEach(y => {
      c.forEach(z => {
        d.forEach(w => {
          let r = f(x, y, z, w);
          if (r !== undefined) {
            ret.contents = ret.contents.concat([Primitive_option.valFromOption(r)]);
            return;
          }
          
        });
      });
    });
  });
  return ret.contents;
}

function combination4(a, b, c, d, f) {
  return combinationIf4(a, b, c, d, (x, y, z, w) => Primitive_option.some(f(x, y, z, w)));
}

let makeBy = Belt_Array.makeBy;

let zipWith = TableclothArray.map2;

export {
  append,
  headUnsafe,
  lastUnsafe,
  tail,
  init,
  uncons,
  singleton,
  makeBy,
  take,
  takeExactly,
  takeWhile,
  drop,
  dropExactly,
  dropWhile,
  tails,
  uniqBy,
  uniq,
  scanl,
  arrayToOption,
  foldl1,
  foldr1,
  unfoldr,
  $$return,
  transpose,
  zipWith,
  liftM2,
  combinationIf2,
  combination2,
  combinationIf3,
  combinationArray3,
  combinationIf4,
  combination4,
}
/* TableclothArray Not a pure module */

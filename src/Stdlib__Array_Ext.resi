/**
  `append(xs, ys)` concatenates two arrays.

  @param {array<'a>} xs - The first array.
  @param {array<'a>} ys - The second array.
  @return {array<'a>} - The concatenated array.
*/
let append: (array<'a>, array<'a>) => array<'a>

/**
  `headUnsafe(xs)` retrieves the first element of an array without performing bounds checking.

  @param {array<'a>} xs - The array from which to retrieve the first element.
  @return {'a} - The first element of the array.
*/
let headUnsafe: array<'a> => 'a

/**
  `lastUnsafe(xs)` retrieves the last element of an array without performing bounds checking.

  @param {array<'a>} xs - The array from which to retrieve the last element.
  @return {'a} - The last element of the array.
*/
let lastUnsafe: array<'a> => 'a

/**
  `tail(xs)` retrieves the tail of an array.

  @param {array<'a>} xs - The array from which to retrieve the tail.
  @return {array<'a>} - A new array containing all elements except the first one.
*/
let tail: array<'a> => array<'a>

/**
  `init(xs)` retrieves all elements of an array except the last one.

  @param {array<'a>} xs - The array from which to retrieve the initial elements.
  @return {option<array<'a>>} - Some containing a new array with all elements except the last one, or None if the array is empty.
*/
let init: array<'a> => option<array<'a>>

/**
  `uncons(xs)` retrieves the first element and the rest of the array as a tuple.

  @param {array<'a>} xs - The array to destructure.
  @return {option<('a, array<'a>)>} - Some containing a tuple with the first element and the rest of the array, or None if the array is empty.
*/
let uncons: array<'a> => option<('a, array<'a>)>

/**
  `singleton(x)` creates an array with a single element.

  @param {'a} x - The element to include in the array.
  @return {array<'a>} - An array containing the single element.
*/
let singleton: 'a => array<'a>

/**
  `makeBy(length, fn)` creates an array of a given length, with each element generated by a function.

  @param {int} length - The length of the array.
  @param {int => 'a} fn - The function to generate each element.
  @return {array<'a>} - The generated array.
*/
let makeBy: (int, int => 'a) => array<'a>

/**
  `take(xs, n)` takes the first n elements of an array.

  @param {array<'a>} xs - The array from which to take elements.
  @param {int} n - The number of elements to take.
  @return {array<'a>} - A new array containing the first n elements.
*/
let take: (array<'a>, int) => array<'a>

/**
  `takeExactly(xs, n)` takes exactly n elements of an array, if possible.

  @param {array<'a>} xs - The array from which to take elements.
  @param {int} n - The number of elements to take.
  @return {option<array<'a>>} - Some containing a new array with n elements, or None if n is out of bounds.
*/
let takeExactly: (array<'a>, int) => option<array<'a>>

/**
  `takeWhile(xs, predicateFn)` takes elements from an array while a predicate function returns true.

  @param {array<'a>} xs - The array from which to take elements.
  @param {'a => bool} predicateFn - The predicate function.
  @return {array<'a>} - A new array containing the elements that satisfy the predicate.
*/
let takeWhile: (array<'a>, 'a => bool) => array<'a>

/**
  `drop(xs, n)` drops the first n elements of an array.

  @param {array<'a>} xs - The array from which to drop elements.
  @param {int} n - The number of elements to drop.
  @return {array<'a>} - A new array containing the remaining elements.
*/
let drop: (array<'a>, int) => array<'a>

/**
  `dropExactly(xs, n)` drops exactly n elements of an array, if possible.

  @param {array<'a>} xs - The array from which to drop elements.
  @param {int} n - The number of elements to drop.
  @return {option<array<'a>>} - Some containing a new array with the remaining elements, or None if n is out of bounds.
*/
let dropExactly: (array<'a>, int) => option<array<'a>>

/**
  `dropWhile(xs, predicateFn)` drops elements from an array while a predicate function returns true.

  @param {array<'a>} xs - The array from which to drop elements.
  @param {'a => bool} predicateFn - The predicate function.
  @return {array<'a>} - A new array containing the remaining elements.
*/
let dropWhile: (array<'a>, 'a => bool) => array<'a>

/**
  `tails(xs)` returns all suffixes of an array.

  @param {array<'a>} xs - The array from which to generate suffixes.
  @return {array<array<'a>>} - An array of all suffixes.
*/
let tails: array<'a> => array<array<'a>>

/**
  `uniqBy(xs, uniqFn)` removes duplicate elements from an array based on a uniqueness function.

  @param {array<'a>} xs - The array from which to remove duplicates.
  @param {'a => 'b} uniqFn - The uniqueness function.
  @return {array<'a>} - A new array with duplicates removed.
*/
let uniqBy: (array<'a>, 'a => 'b) => array<'a>

/**
  `uniq(xs)` removes duplicate elements from an array.

  @param {array<'a>} xs - The array from which to remove duplicates.
  @return {array<'a>} - A new array with duplicates removed.
*/
let uniq: array<'a> => array<'a>

/**
  `scanl(xs, initial, fn)` applies a function to each element of an array, accumulating the results.

  @param {array<'b>} xs - The array to scan.
  @param {'a} initial - The initial value.
  @param {('a, 'b) => 'a} fn - The function to apply.
  @return {array<'a>} - An array of accumulated results.
*/
let scanl: (array<'b>, 'a, ('a, 'b) => 'a) => array<'a>

/**
  `arrayToOption(xs)` converts an array to an option type.

  @param {array<'a>} xs - The array to convert.
  @return {option<'a>} - Some containing the first element of the array if it is not empty, or None if the array is empty.
*/
let arrayToOption: array<'a> => option<'a>

/**
  `foldl1(xs, f)` folds an array from the left, using the first element as the initial value.

  @param {array<'a>} xs - The array to fold.
  @param {('a, 'a) => 'a} f - The function to apply.
  @return {'a} - The result of the fold.
*/
let foldl1: (array<'a>, ('a, 'a) => 'a) => 'a

/**
  `foldr1(xs, f)` folds an array from the right, using the last element as the initial value.

  @param {array<'a>} xs - The array to fold.
  @param {('a, 'a) => 'a} f - The function to apply.
  @return {'a} - The result of the fold.
*/
let foldr1: (array<'a>, ('a, 'a) => 'a) => 'a

/**
  `unfoldr(initial, f)` unfolds an array from an initial value using a function.

  @param {'b} initial - The initial value.
  @param {'b => option<('a, 'b)>} f - The function to apply.
  @return {array<'a>} - The unfolded array.
*/
let unfoldr: ('b, 'b => option<('a, 'b)>) => array<'a>

/**
  `return(x)` wraps a value in an array.

  @param {'a} x - The value to wrap.
  @return {array<'a>} - An array containing the value.
*/
let return: 'a => array<'a>

/**
  `transpose(a)` transposes a 2D array.

  @param {array<array<'a>>} a - The 2D array to transpose.
  @return {array<array<'a>>} - The transposed array.
*/
let transpose: array<array<'a>> => array<array<'a>>

/**
  `zipWith(a, b, f)` combines two arrays using a function.

  @param {array<'a>} a - The first array.
  @param {array<'b>} b - The second array.
  @param {('a, 'b) => 'c} f - The function to apply to each pair of elements.
  @return {array<'c>} - The array of results.
*/
let zipWith: (array<'a>, array<'b>, ('a, 'b) => 'c) => array<'c>

/**
  `liftM2(f, m1, m2)` applies a binary function to two arrays, combining their elements.

  @param {('a, 'b) => 'c} f - The binary function to apply.
  @param {array<'a>} m1 - The first array.
  @param {array<'b>} m2 - The second array.
  @return {array<'c>} - The array of results.
*/
let liftM2: (('a, 'b) => 'c, array<'a>, array<'b>) => array<'c>

/**
  `combinationIf2(a, b, f)` combines two arrays using a function that returns an option type.

  @param {array<'a>} a - The first array.
  @param {array<'b>} b - The second array.
  @param {('a, 'b) => option<'r>} f - The function to apply to each pair of elements.
  @return {array<'r>} - The array of results, excluding None values.
*/
let combinationIf2: (array<'a>, array<'b>, ('a, 'b) => option<'r>) => array<'r>

/**
  `combination2(a, b, f)` combines two arrays using a function.

  @param {array<'a>} a - The first array.
  @param {array<'b>} b - The second array.
  @param {('a, 'b) => 'r} f - The function to apply.
  @return {array<'r>} - The combined array.
*/
let combination2: (array<'a>, array<'b>, ('a, 'b) => 'r) => array<'r>

/**
  `combinationIf3(a, b, c, f)` combines three arrays using a function that returns an option type.

  @param {array<'a>} a - The first array.
  @param {array<'b>} b - The second array.
  @param {array<'c>} c - The third array.
  @param {('a, 'b, 'c) => option<'r>} f - The function to apply to each triplet of elements.
  @return {array<'r>} - The array of results, excluding None values.
*/
let combinationIf3: (array<'a>, array<'b>, array<'c>, ('a, 'b, 'c) => option<'r>) => array<'r>

/**
  `combinationArray3(a, b, c, f)` combines three arrays using a function.

  @param {array<'a>} a - The first array.
  @param {array<'b>} b - The second array.
  @param {array<'c>} c - The third array.
  @param {('a, 'b, 'c) => 'r} f - The function to apply.
  @return {array<'r>} - The combined array.
*/
let combinationArray3: (array<'a>, array<'b>, array<'c>, ('a, 'b, 'c) => 'r) => array<'r>

/**
  `combinationIf4(a, b, c, d, f)` combines four arrays using a function that returns an option type.

  @param {array<'a>} a - The first array.
  @param {array<'b>} b - The second array.
  @param {array<'c>} c - The third array.
  @param {array<'d>} d - The fourth array.
  @param {('a, 'b, 'c, 'd) => option<'r>} f - The function to apply to each quartet of elements.
  @return {array<'r>} - The array of results, excluding None values.
*/
let combinationIf4: (
  array<'a>,
  array<'b>,
  array<'c>,
  array<'d>,
  ('a, 'b, 'c, 'd) => option<'r>,
) => array<'r>

/**
  `combination4(a, b, c, d, f)` combines four arrays using a function.

  @param {array<'a>} a - The first array.
  @param {array<'b>} b - The second array.
  @param {array<'c>} c - The third array.
  @param {array<'d>} d - The fourth array.
  @param {('a, 'b, 'c, 'd) => 'r} f - The function to apply.
  @return {array<'r>} - The combined array.
*/
let combination4: (array<'a>, array<'b>, array<'c>, array<'d>, ('a, 'b, 'c, 'd) => 'r) => array<'r>
